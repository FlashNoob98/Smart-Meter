/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <my_structures.h>
#include <math.h>
//#define PI 3.14159265358

#define RCC ((RCC_Type*) 0x40021000) //Indirizzo di Base RCC
#define GPIOA ((GPIO_Type*) 0x48000000) //Indirizzo di base GPIOA
#define GPIOE ((GPIO_Type*) 0x48001000) //Indirizzo di base GPIOE
#define GPIOC ((GPIO_Type*) 0x48000800) //Indirizzo base GPIOC (USART1)
//#define TIM2 ((TIMER_Type*) 0x40000000) //Indirizzo base timer 2
#define TIM6 ((TIMER_Type*) 0x40001000) //Indirizzo base timer 6

#define ADC1 ((ADC_Type*) 0x50000000) //Indirizzo base ADC1
#define ADC2 ((ADC_Type*) 0x50000100) //Indirizzo base ADC2
#define ADC12 ((ADC_COMMON_Type*) 0x50000300) //Indirizzo comune ADC12

#define DAC1 ((DAC_Type*) 0x40007400) //Indirizzo base DAC1

#define USART1 ((USART_Type*) 0x40013800) //Indirizzo base USART1

//#define GPIOAEN (1<<17)
//#define GPIOEEN (1<<21)
//#define LED_BLU (1<<8)

#define Input 0	//0b00
#define Output 1	//0b01
#define Alternate 2	//0b10
#define Analog 3	//0b11

#define LED_8 (GPIOE->ODR8)
#define USER_BTN (GPIOA->IDR0)

//static float misura;
unsigned int misura;
static char a;
static char b;

int main(void){
	unsigned int clear;
	//Abilita il clock per GPIOA e GPIOE
	//RCC->AHBENR|=GPIOAEN|GPIOEEN; //Enable GPIOE e GPIOA
	RCC->GPIOAEN = 1; //EnableGPIOA

	RCC->GPIOCEN = 1; //Enable GPIOC
	RCC->USART1EN=1; //Enable USART1
	GPIOC->MODER4 = Alternate; //USART1 TX
	GPIOC->MODER5 = Alternate; //USART1 RX
	GPIOC->AFRLAFR4 = 0b0111; //Usart Alternate function FA7
	GPIOC->AFRLAFR5 = 0b0111; //Usart function FA7

	USART1->BRR = 833;//Definisci Baudrate USART ovvero 9600 bps con fck 8MHz
	USART1->UE=1; //UE = 1 abilita Usart 1

	GPIOA->MODER4 = Analog; //DAC metti pin 4 in modalità analogica
	GPIOA->MODER5 = Analog; //Abilita modalità analogica su pin PA5

	RCC->DAC1EN=1; //Abilita il DAC
	DAC1->DACC1DHRR1 = 2048; //Valore iniziale
	DAC1->EN1=1; //EN1 Abilita canale 1 Dac 1
	DAC1->BOFF1=1; //Disabilitazione buffer (carico alta impedenza)


	unsigned int Npp = 100;
	unsigned int y[100];
	float x = 0.0;
	float dx = (float)(2*M_PI/Npp);

	for (int i=0; i<Npp; i++){
		y[i] = (unsigned int)(2048+(2047*sinf(x)));
		x = x + dx;
		//DAC1->DACC1DHRR1 = y[i];
	}//END FOR


	RCC->ADC12EN = 1; //Abilita ADC12 nell'RCC
	ADC12->CKMODE = 0b01; //CKMODE 01 syncronous clock mode
	//ADC12->DUAL = 0b0000; //Modalità indipendente degli ADC
	ADC2->ADVREGEN = 0b00;//Attiva regolatore di tensione fase intermedia
	ADC2->ADVREGEN = 0b01;//Attiva regolatore di tensione accensione

	//Abilito i timer
	RCC->GPIOEEN = 1; //Enable GPIOE
	//GPIOE->MODER8 = Output;//Output MODE Led 8
	GPIOE->MODER = 0x55550000; //led output da 8 a 15
	//RCC->TIM2EN=1; //enable timer2
	RCC->TIM6EN = 1; //enable timer 6
	TIM6->ARR = (unsigned int) 62500; //500ms ovvero 4000000 count
	TIM6->PSC = (unsigned int) 63;
	TIM6->CEN = 1;//Avvia timer 6



	// Attendi 10 us
	while(TIM6->UIF){ //Verifica quando avviene l'overflow (500ms)
		TIM6->UIF = 0;
	}

	ADC2->DIFSEL=(0<<1); //Imposta in single ended il secondo canale dell ADC2

	//Calibrazione
	ADC2->ADEN=0; //Spegni ADC (superfluo la prima volta)
	ADC2->ADCALDIF=0;//Imposta calibrazione single ended
	ADC2->ADCAL=1; //Avvia
	while (ADC2->ADCAL!=0); //Attendi termine calibrazione

	//Abilitazione ADC
	ADC2->ADEN=1; //Abilita ADC
	while (ADC2->ADRDY!=1); //Attendi commutazione Ready
	ADC2->ADRDY=0; //Riabbassa bit ready (per eventuali acquisizioni successive)

	//Definizione sequenza di acquisizione
	//PA1 è collegato al canale ADC1_IN2
	ADC2->L=1-1; //Lunghezza azquisizione = 1(-1), un solo canale
	ADC2->SQ1=2; //Canale 2 nella posizione di sequenza 1

	//Impostare il tempo di sampling (sul canale 2)
	//ADC2->SMP2 = 7; // (0b111) 601.5 volte il clock dell'ADC
	ADC2->SMP2 = 2;



    //Fine setup
	while(1){	//Main loop
		LED_8 = 1; //Accendi LED 8
//		while(!USER_BTN);//Aspetto fino a che Tasto Ã¨ 0 (Non Premuto)
//  	while(USER_BTN);//Aspetto fino a che Tasto Ã¨ 1 (Premuto)
		//TIM2->CNT = 0;//Reimposta contatore 2 (conta secondi)
		//TIM6->CNT = 0; //Reimposta contatore 6 (animazione LED)

		//while(!USER_BTN){
			//GPIOE->ODR = (GPIOE->ODR)+(1<<8); Messo qui mostra una combinazione "casuale" ogni volta che trattieni il tasto
			if(TIM6->UIF){ //Verifica quando avviene l'overflow
				if (clear){
					GPIOE->ODR|=0x0080; //Riparti dal led 7 (Solo animazione orologio
					GPIOE->ODR=0; //Spegni tutto (Entrambe le animazioni o solo accumulo)
					clear = 0;
				}
				TIM6->UIF = 0; //Reimposta UIF ovvero accetta evento di overflow
				//LED_8 ^= 1; //Commuta LED 8
				GPIOE->ODR = ((GPIOE->ODR)<<1); //ANIMAZIONE "orologio"
				GPIOE->ODR = (GPIOE->ODR)+(1<<8); //ANIMAZIONE "accumulo binario"
				if (((GPIOE->ODR)==(0xff00))||((GPIOE->ODR)==(0x0000))){ //Quando termini i LED riparti dal numero 8
					//LED_8=1;
					clear = 1;
			//	}


				//TIM6->ARR = 62500*misura/3.3+1; //Velocizza
			}//Durante la misura


		};
			//GPIOE->ODR=0;
		//Quarta funzione
			USART1->TE=1; //TE Idle frame

			for (int i=0; i<100;i++){
			DAC1->DACC1DHRR1 = y[i];
			ADC1->ADSTART=1; //Inizia conversione (è il master ad avviare la conversione)
			while (ADC1->EOC!=1); //Attendi fine conversione (sempre del master)
			//misura = (float)(ADC2->RDATA)/4096*3.3; //Leggi data register
			misura = ADC2->RDATA; //Acquisisci dato
			a = misura;
			b = (misura>>8);
			while((USART1->TXE)==0); //Attendi  BIT TXE
			USART1->TDR = a;
			while((USART1->TXE)==0); //Attendi  BIT TXE
			USART1->TDR = b;
			while ((USART1->TXE)==0);
			USART1->TDR = (char)'\r';
			//(USART1->ISR)|=(0<<7);SPI4E
			//}
			}

	}//end while
}//END MAIN
